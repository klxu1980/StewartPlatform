//---------------------------------------------------------------------------


#pragma hdrstop

#include "RobotIKP.h"
//---------------------------------------------------------------------------

#pragma package(smart_init)
//---------------------------------------------------------------------------
// CalcGlobalCoordination()
//---------------------------------------------------------------------------
void CRobotIKP::CalcGlobalCoordination(double Pos[3], double Euler[3],
                                       double PosLocal[][3], double PosGlobal [][3], int Count)
{
   // 获得旋转矩阵
   double RMatrix[3][3];
   RotateMatrixByEuler(RMatrix, Euler);

   // 将每个点映射到全局坐标系
   for(int i = 0; i < Count; ++i)
   {
      MatrixMultiVector(PosGlobal[i], RMatrix, PosLocal[i]);
      VectorAddVector(PosGlobal[i], PosGlobal[i], Pos);
   }
}
//---------------------------------------------------------------------------
// CalcGlobalCoordination()
//---------------------------------------------------------------------------
void CRobotIKP::CalcGlobalCoordination(double X, double Y, double Z, double Yaw, double Pitch, double Roll,
                                       double PosLocal[][3], double PosGlobal [][3], int Count)
{
   double Pos[3] = {X, Y, Z};
   double Eurlar[3] = {Yaw, Pitch, Roll};

   CalcGlobalCoordination(Pos, Eurlar, PosLocal, PosGlobal, Count);
}
//---------------------------------------------------------------------------
// CalcGlobalCoordination()
//---------------------------------------------------------------------------
void CRobotIKP::CalcGlobalCoordination(double PosLocal[][3], double PosGlobal [][3], int Count)
{  
   CalcGlobalCoordination(UpperPos, UpperEuler, PosLocal, PosGlobal, Count);
}
//---------------------------------------------------------------------------
// Move()
//---------------------------------------------------------------------------
void CRobotIKP::Move(double X, double Y, double Z, double Yaw, double Pitch, double Roll)
{
   // 拷贝位姿
   CopyVector(UpperPos,   X, Y, Z);
   CopyVector(UpperEuler, Yaw, Pitch, Roll);

   // 计算上平台铰接点在下平台坐标系中的坐标
   CalcGlobalCoordination(UpperPos, UpperEuler, UpperJointInUpperCoordinate, UpperJointInLowerCoordinate, 6);

   // 计算连杆长度
   CalcJackLength(JackLength);
}
//---------------------------------------------------------------------------
void CRobotIKP::CalcForceOfJacks(double Force[3], double Torque[3])
{
   // 计算每个连杆作用力的方向矢量，方向为下平台指向上平台(即，默认情况下连杆承受压力)
   double FV[6][3];
   for(int i = 0; i < 6; ++i)
   {
      FV[i][0] = Jack[i].UpperJoint[0] - Jack[i].LowerJoint[0];
      FV[i][1] = Jack[i].UpperJoint[1] - Jack[i].LowerJoint[1];
      FV[i][2] = Jack[i].UpperJoint[2] - Jack[i].LowerJoint[2];

      Normalize(FV[i]);
   }

   // 计算质心位置
   double MidPos[3];
   MatrixMultiVector(MidPos, __RMatrix, __Middle);
   VectorAddVector(MidPos, MidPos, __UpperPos);

   // 计算力臂矢量，该矢量应当由铰接点指向质心
   double Arm[6][3];
   for(int i = 0; i < 6; ++i)
      VectorSubVector(Arm[i], UpperPlatform[i], MidPos);

   // 计算力矩矢量，即连杆作用力方向矢量与力臂矢量之间的叉积
   double TV[6][3];
   for(int i = 0; i < 6; ++i)
      CalcCrossProduct(TV[i], FV[i], Arm[i]);

   // 通过求解线性方程获得每个连杆的力
   // 线性方程组的形式如下：
   // F[0]FV[0] + F[1]FV[1] + ... + F[5]FV[5] = Force     (连杆力的合力等于上平台所受力)
   // F[0]TV[0] + F[1]TV[1] + ... + F[5]TV[5] = Torque    (连杆力矩的合力矩等于上平台所受力矩)
   Mat_DP M(6, 6);
   for(int i = 0; i < 6; ++i)
   {
      M[0][i] = FV[i][0];
      M[1][i] = FV[i][1];
      M[2][i] = FV[i][2];

      M[3][i] = TV[i][0];
      M[4][i] = TV[i][1];
      M[5][i] = TV[i][2];
   }

   // 外部力和力矩
   Mat_DP F(6, 1);
   F[0][0] = Force[0];
   F[1][0] = Force[1];
   F[2][0] = Force[2];

   F[3][0] = Torque[0];
   F[4][0] = Torque[1];
   F[5][0] = Torque[2];

   // 通过高斯消元法求解连杆力
   NR::gaussj(M, F);
   for(int i = 0; i < 6; ++i)
      Jack[i].Force = F[i][0];
}
